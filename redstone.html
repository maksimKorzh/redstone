<style>html, body, canvas { margin: 0px; padding: 0px; }</style>
<canvas id="screen" style="width: 100%; height: 100%"/>
<script>
  // Rasterizer displaying rotating cube, port of One Lone Coder's C++ 3D engine tutorials's

  // init canvas
  const canvas = document.getElementById('screen');
  const context = canvas.getContext('2d');
  
  // FPS
  const FPS = 60;
  const cycleDelay = Math.floor(1000 / FPS);
  var oldCycleTime = 0;
  var cycleCount = 0;
  var fps_rate = '...';
  
  // resolution  
  const WIDTH = window.innerWidth;
  const HEIGHT = window.innerHeight;
  
  // rasterizer
  var near = 0.1;
  var far = 1000.0;
  var fov = 90.0;
  var aspectRatio = HEIGHT / WIDTH;
  var fovRad = 1.0 / Math.tan(fov * 0.5 / 180.0 * 3.14159);
  var viewAngle = 0.0;
  
  // camera
  var camera = [0.0, 0.0, 0.0];
  var lookDirection = [0.0, 0.0, 0.0];
  
  // projection
  var matrixProjected = matrixMakeProjection(90.0, HEIGHT / WIDTH, 0.1, 1000.0);
  
  // mesh
  var cube = [
    // south
    [[0.0, 0.0, 0.0], [0.0, 1.0, 0.0], [1.0, 1.0, 0.0]],
    [[0.0, 0.0, 0.0], [1.0, 1.0, 0.0], [1.0, 0.0, 0.0]],
    
    // east
    [[1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, 1.0]],
    [[1.0, 0.0, 0.0], [1.0, 1.0, 1.0], [1.0, 0.0, 1.0]],
    
    // north
    [[1.0, 0.0, 1.0], [1.0, 1.0, 1.0], [0.0, 1.0, 1.0]],
    [[1.0, 0.0, 1.0], [0.0, 1.0, 1.0], [0.0, 0.0, 1.0]],
    
    // west
    [[0.0, 0.0, 1.0], [0.0, 1.0, 1.0], [0.0, 1.0, 0.0]],
    [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [0.0, 0.0, 0.0]],
    
    // top
    [[0.0, 1.0, 0.0], [0.0, 1.0, 1.0], [1.0, 1.0, 1.0]],
    [[0.0, 1.0, 0.0], [1.0, 1.0, 1.0], [1.0, 1.0, 0.0]],
    
    // bottom
    [[1.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 0.0]],
    [[1.0, 0.0, 1.0], [0.0, 0.0, 0.0], [1.0, 0.0, 0.0]],
  ];
  
  // create 4x4 matrix instance
  function createMatrix() {
    return matrix = [
      [0.0, 0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0, 0.0],
    ];
  }

  function matrixMultiplyVector(m, i) {
    var v = [0.0, 0.0, 0.0, 0.0];
    v[0] = i[0] * m[0][0] + i[1] * m[1][0] + i[2] * m[2][0] + i.w * m[3][0];
    v[1] = i[0] * m[0][1] + i[1] * m[1][1] + i[2] * m[2][1] + i.w * m[3][1];
    v[2] = i[0] * m[0][2] + i[1] * m[1][2] + i[2] * m[2][2] + i.w * m[3][2];
    v[3] = i[0] * m[0][3] + i[1] * m[1][3] + i[2] * m[2][3] + i.w * m[3][3];
    return v;
  }

  function matrixMakeIdentity() {
    var matrix = createMatrix();
    matrix[0][0] = 1.0;
    matrix[1][1] = 1.0;
    matrix[2][2] = 1.0;
    matrix[3][3] = 1.0;
    return matrix;
  }
  
  // matrix rotation X
  function matrixMakeRotationX(angleRad) {
    var matrix = createMatrix();
    matrix[0][0] = 1.0;
    matrix[1][1] = Math.cos(angleRad);
    matrix[1][2] = Math.sin(angleRad);
    matrix[2][1] = -Math.sin(angleRad);
    matrix[2][2] = Math.cos(angleRad);
    matrix[3][3] = 1.0;
    return matrix;
  }
  
  // matrix rotation Y
  function matrixMakeRotationY(angleRad) {
    var matrix = createMatrix();
    matrix[0][0] = Math.cos(angleRad);
    matrix[0][2] = Math.sin(angleRad);
    matrix[2][0] = -Math.sin(angleRad);
    matrix[1][1] = 1.0;
    matrix[2][2] = Math.cos(angleRad);
    matrix[3][3] = 1.0;
    return matrix;
  }
  
  // matrix rotation Z
  function matrixMakeRotationZ(angleRad) {
    var matrix = createMatrix();
    matrix[0][0] = Math.cos(angleRad);
    matrix[0][1] = Math.sin(angleRad);
    matrix[1][0] = -Math.sin(angleRad);
    matrix[1][1] = Math.cos(angleRad);
    matrix[2][2] = 1.0;
    matrix[3][3] = 1.0;
    return matrix;
  }

	// matrix translation
  function matrixMakeTranslation(x, y, z) {
    var matrix = createMatrix();
    matrix[0][0] = 1.0;
    matrix[1][1] = 1.0;
    matrix[2][2] = 1.0;
    matrix[3][3] = 1.0;
    matrix[3][0] = x;
    matrix[3][1] = y;
    matrix[3][2] = z;
    return matrix;
  }

  // matrix projection
  function matrixMakeProjection(fovDegrees, aspectRatio, near, far) {
    fovRad = 1.0 / Math.tan(fovDegrees * 0.5 / 180.0 * 3.14159);
    matrix = createMatrix();
    matrix[0][0] = aspectRatio * fovRad;
    matrix[1][1] = fovRad;
    matrix[2][2] = far / (far - near);
    matrix[3][2] = (-far * near) / (far - near);
    matrix[2][3] = 1.0;
    matrix[3][3] = 0.0;
    return matrix;
  }

  // matrix multiplication
  function multiplyMatrixVector(i, o, m) {
    o[0] = i[0] * m[0][0] + i[1] * m[1][0] + i[2] * m[2][0] + m[3][0];
    o[1] = i[0] * m[0][1] + i[1] * m[1][1] + i[2] * m[2][1] + m[3][1];
    o[2] = i[0] * m[0][2] + i[1] * m[1][2] + i[2] * m[2][2] + m[3][2];
    w = i[0] * m[0][3] + i[1] * m[1][3] + i[2] * m[2][3] + m[3][3];
    if (w != 0.0) { o[0] /= w; o[1] /= w; o[2] /= w; }
  }
  
  // Only for Rotation/Translation Matrices
  function matrixQuickInverse(m) {
    var matrix = createMatrix();
    matrix[0][0] = m[0][0]; matrix[0][1] = m[1][0]; matrix[0][2] = m[2][0]; matrix[0][3] = 0.0;
		matrix[1][0] = m[0][1]; matrix[1][1] = m[1][1]; matrix[1][2] = m[2][1]; matrix[1][3] = 0.0;
		matrix[2][0] = m[0][2]; matrix[2][1] = m[1][2]; matrix[2][2] = m[2][2]; matrix[2][3] = 0.0;
		matrix[3][0] = -(m[3][0] * matrix[0][0] + m[3][1] * matrix[1][0] + m[3][2] * matrix[2][0]);
		matrix[3][1] = -(m[3][0] * matrix[0][1] + m[3][1] * matrix[1][1] + m[3][2] * matrix[2][1]);
		matrix[3][2] = -(m[3][0] * matrix[0][2] + m[3][1] * matrix[1][2] + m[3][2] * matrix[2][2]);
		matrix[3][3] = 1.0;
		return matrix;
  }
  
  // mulyiply vectors
  function vectorMul(v1, k) {
    return [ v1[0] * k, v1[1] * k, v1[2] * k ];
  }

  // add vectors
  function vectorAdd(v1, v2) {
    return [ v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2] ];
  }

  // subtract vectors
  function vectorSub(v1, v2) {
    return [ v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2] ];
  }
  
  // vector dot product
  function vectorDotProduct(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2] * v2[2];
  }
	
  // vector length
  function vectorLength(v) {
    return Math.sqrt(vectorDotProduct(v, v));
  }
  
  // vector cross product
  function vectorCrossProduct(v1, v2) {
		let v = [0.0, 0.0, 0.0];
		v[0] = v1[1] * v2[2] - v1[2] * v2[1];
		v[1] = v1[2] * v2[0] - v1[0] * v2[2];
		v[2] = v1[0] * v2[1] - v1[1] * v2[0];
		return v;
	}
  
  // multiply matrices
  function matrixMultiplyMatrix(m1, m2) {
    var matrix = createMatrix();
    for (let c = 0; c < 4; c++)
      for (let r = 0; r < 4; r++)
        matrix[r][c] = m1[r][0] * m2[0][c] + m1[r][1] * m2[1][c] + m1[r][2] * m2[2][c] + m1[r][3] * m2[3][c];
    return matrix;
  }

  // normalize vector
  function vectorNormalize(v) {
    let l = vectorLength(v);
    return [ v[0] / l, v[1] / l, v[2] / l ];
  }
  
  // matrix point at
  function matrixPointAt(pos, target, up)
  {
    // Calculate new forward direction
    let newForward = vectorSub(target, pos);
    newForward = vectorNormalize(newForward);

    // Calculate new Up direction
    let a = vectorMul(newForward, vectorDotProduct(up, newForward));
    let newUp = vectorSub(up, a);
    newUp = vectorNormalize(newUp);

    // New Right direction is easy, its just cross product
    let newRight = vectorCrossProduct(newUp, newForward);

    // Construct Dimensioning and Translation Matrix
    return [
      [newRight[0], newRight[1], newRight[2], 0.0],
      [newUp[0], newUp[1], newUp[2], 0.0],
      [newForward[0], newForward[1], newForward[2], 0.0],
      [pos[0], pos[1], pos[2], 1.0]
    ]
  }

  // render with shading
  function fillTriangle(x1, y1, x2, y2, x3, y3, color) {
    context.fillStyle = color;
    context.strokeStyle = color;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(x3, y3);
    context.lineTo(x1, y1);
    context.closePath();
    context.stroke();
    context.fill();
  }
  
  // render triangle
  function drawTriangle(x1, y1, x2, y2, x3, y3, color) {
    context.strokeStyle = color;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(x3, y3);
    context.lineTo(x1, y1);
    context.closePath();
    context.stroke();
  }
  
  // shading
  function getColor(dp) {
    let color = parseInt(dp*100) + 100;
    return 'rgb(' + color + ', ' + color + ', ' + color + ')';
  }

  // game loop
  function gameLoop() {
    // calculate FPS
    cycleCount++;
    if (cycleCount >= 60) cycleCount = 0;
    var startTime = Date.now();
    var cycleTime = startTime - oldCycleTime;
    oldCycleTime = startTime;
    if (cycleCount % 60 == 0) fps_rate = Math.floor(1000 / cycleTime);
    
    // resize canvas
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    
    // update screen
    context.fillStyle = 'Black';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Set up rotation matrices
		viewAngle += 0.01;
    matrixRotateZ = matrixMakeRotationZ(viewAngle * 0.5);
    matrixRotateX = matrixMakeRotationX(viewAngle);
    

    let matrixTranslation = createMatrix();
		matrixTranslation = matrixMakeTranslation(0.0, 0.0, 5.0);

		let matrixWorld = createMatrix();
		matrixWorld = matrixMakeIdentity();	// Form World Matrix
		matrixWorld = matrixMultiplyMatrix(matrixRotateZ, matrixRotateX); // Transform by rotation
		matrixWorld = matrixMultiplyMatrix(matrixWorld, matrixTranslation); // Transform by translation

		// Create "Point At" Matrix for camera
		lookDirection = [0, 0, 1];
		let up = [0,1,0];
		let target = vectorAdd(camera, lookDirection);//[0,0,1];
		
		
		
		//let matrixCameraRotate = matrixMakeRotationY(fYaw);
		//vLookDir = Matrix_MultiplyVector(matCameraRot, vTarget);
		//vTarget = Vector_Add(vCamera, vLookDir);
		
		let matrixCamera = matrixPointAt(camera, target, up);

		// Make view matrix from camera
		let matrixView = matrixQuickInverse(matrixCamera);

		// Store triagles for rastering later
		//vector<triangle> vecTrianglesToRaster;
    
    for (let i = 0; i < cube.length; i++) {
      // define triangles
      
      triangleRotatedZ = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]];
      triangleRotatedZX = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]];
      
      let triangleMesh = cube[i];
      let triangleProjected = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]];
      let triangleTransformed = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]];
      let triangleViewed = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]];

      triangleTransformed[0] = matrixMultiplyVector(matrixWorld, triangleMesh[0]);
      triangleTransformed[1] = matrixMultiplyVector(matrixWorld, triangleMesh[1]);
      triangleTransformed[2] = matrixMultiplyVector(matrixWorld, triangleMesh[2]);      
            
      // Rotate in Z-Axis
			multiplyMatrixVector(triangleMesh[0], triangleRotatedZ[0], matrixRotateZ);
			multiplyMatrixVector(triangleMesh[1], triangleRotatedZ[1], matrixRotateZ);
			multiplyMatrixVector(triangleMesh[2], triangleRotatedZ[2], matrixRotateZ);

			// Rotate in X-Axis
			multiplyMatrixVector(triangleRotatedZ[0], triangleRotatedZX[0], matrixRotateX);
			multiplyMatrixVector(triangleRotatedZ[1], triangleRotatedZX[1], matrixRotateX);
			multiplyMatrixVector(triangleRotatedZ[2], triangleRotatedZX[2], matrixRotateX);
      
      // offset into the screen
			triangleTranslated = JSON.parse(JSON.stringify(triangleRotatedZX));
			triangleTranslated[0][2] = triangleRotatedZX[0][2] + 3.0;
			triangleTranslated[1][2] = triangleRotatedZX[1][2] + 3.0;
			triangleTranslated[2][2] = triangleRotatedZX[2][2] + 3.0;
      
      // use Cross-Product to get surface normal
			let normal = [0.0, 0.0, 0.0];
			let line1 = [0.0, 0.0, 0.0];
			let line2 = [0.0, 0.0, 0.0];
			
      // Use Cross-Product to get surface normal
      line1 = vectorSub(triangleTranslated[1], triangleTranslated[0]);
      line2 = vectorSub(triangleTranslated[2], triangleTranslated[0]);
      
      //line1 = vectorSub(triangleTransformed[1], triangleTransformed[0]);
      //line2 = vectorSub(triangleTransformed[2], triangleTransformed[0]);
      
      // It's normally normal to normalise the normal
      normal = vectorCrossProduct(line1, line2);
      normal = vectorNormalize(normal);
      
      // Get Ray from triangle to camera
			let cameraRay = vectorSub(triangleTransformed[0], camera);

      // render only visible area
      if(normal[0] * (triangleTranslated[0][0] - camera[0]) + 
			   normal[1] * (triangleTranslated[0][1] - camera[1]) +
			   normal[2] * (triangleTranslated[0][2] - camera[2]) < 0) {
			
			/*if(normal[0] * (triangleTransformed[0][0] - camera[0]) + 
			   normal[1] * (triangleTransformed[0][1] - camera[1]) +
			   normal[2] * (triangleTransformed[0][2] - camera[2]) < 0) {*/
			  
			//if (vectorDotProduct(normal, cameraRay) < 0.0) {console.log('should render')
        
        // illumination
				let lightDirection = [0.0, 1.0, -1.0];
				let l = Math.sqrt(lightDirection[0]*lightDirection[0] + 
				                  lightDirection[1]*lightDirection[1] +
				                  lightDirection[2]*lightDirection[2]);

				lightDirection = vectorNormalize(lightDirection);
				let dp = Math.max(0.1, vectorDotProduct(lightDirection, normal));

				// choose console colors as required (much easier with RGB)
				let color = getColor(dp);
        
        // convert world space to view space
        /*triangleViewed[0] = matrixMultiplyVector(matrixView, triangleTransformed[0]);
        triangleViewed[1] = matrixMultiplyVector(matrixView, triangleTransformed[1]);
        triangleViewed[2] = matrixMultiplyVector(matrixView, triangleTransformed[2]);

        // project triangles from 3D --> 2D
        triangleProjected[0] = matrixMultiplyVector(matrixProjected, triangleViewed[0]);
        triangleProjected[1] = matrixMultiplyVector(matrixProjected, triangleViewed[1]);
        triangleProjected[2] = matrixMultiplyVector(matrixProjected, triangleViewed[2]);*/
        
        
        
        multiplyMatrixVector(triangleTranslated[0], triangleProjected[0], matrixProjected);
        multiplyMatrixVector(triangleTranslated[1], triangleProjected[1], matrixProjected);
        multiplyMatrixVector(triangleTranslated[2], triangleProjected[2], matrixProjected);

        // scale into view
        triangleProjected[0][0] += 1.0; triangleProjected[0][1] += 1.0;
        triangleProjected[1][0] += 1.0; triangleProjected[1][1] += 1.0;
        triangleProjected[2][0] += 1.0; triangleProjected[2][1] += 1.0;
        triangleProjected[0][0] *= 0.5 * WIDTH;
        triangleProjected[0][1] *= 0.5 * HEIGHT;
        triangleProjected[1][0] *= 0.5 * WIDTH;
        triangleProjected[1][1] *= 0.5 * HEIGHT;
        triangleProjected[2][0] *= 0.5 * WIDTH;
        triangleProjected[2][1] *= 0.5 * HEIGHT;

        // shading
        fillTriangle(triangleProjected[0][0], triangleProjected[0][1],
          triangleProjected[1][0], triangleProjected[1][1],
          triangleProjected[2][0], triangleProjected[2][1],
          color);
        
        // triangles
        /*drawTriangle(triangleProjected[0][0], triangleProjected[0][1],
          triangleProjected[1][0], triangleProjected[1][1],
          triangleProjected[2][0], triangleProjected[2][1],
          'Black');*/
      }
    }
    
    // infinite loop
    setTimeout(gameLoop, cycleDelay);
    
    // render FPS to screen
    context.fillStyle = 'white';
    context.font = '10px Monospace';
    context.fillText('FPS: ' + fps_rate, 0, 20);
    
  } window.onload = function() { gameLoop(); }
  
</script>