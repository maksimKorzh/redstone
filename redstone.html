<style>html, body, canvas { margin: 0px; padding: 0px; }</style>
<canvas id="screen" style="width: 100%; height: 100%"/>
<script>
  // init canvas
  const canvas = document.getElementById('screen');
  const context = canvas.getContext('2d');

  // FPS
  const FPS = 60;
  const cycleDelay = Math.floor(1000 / FPS);
  var oldCycleTime = 0;
  var cycleCount = 0;
  var fps_rate = '...';
  
  // resolution  
  const WIDTH = window.innerWidth;
  const HEIGHT = window.innerHeight;
  
  // graphics settings
  const NODE_RADIUS = 5;
  const NODE_COLOR = 'White';
  const NODE_LINE_WIDTH = 2;
  const WIRE_COLOR_OFF = '#006600';
  const WIRE_COLOR_ON = '#00FF00';
  const WIRE_LINE_WIDTH = 4;
  
  // circuit representation
  var circuit = [
    node1 = createNode(100, 100, true),
    node2 = createNode(150, 100, false),
    node3 = createNode(200, 200, false),
    node4 = createNode(300, 300, false),
    createWire(node1, node2),
    createInverter(node2, node3),
    createWire(node3, node4),
  ];
  /*
    dot
    line
    
  */
  
  // node class
  function createNode(x, y, active) {
    return {
      'class': 'node',
      'x': x,
      'y': y,
      'state': false,
      'active': active,
      'onClick': function() { this.state = this.state ? false : true; },
      'function': function () { /* just a placeholder */ }
    };
  }
  
  // wire class
  function createWire(node1, node2) {
    return {
      'class': 'wire',
      'in': node1,
      'out': node2,
      'state': false,
      'function': function() {
        if (this.state == false && (this.in.state == true || this.out.state == true)) {
          this.state = true;
          this.in.state = this.state;
          this.out.state = this.state;
        }
        if (this.state == true && (this.in.state == false || this.out.state == false)) {
          this.state = false;
          this.in.state = this.state;
          this.out.state = this.state;
        }
      }
    };
  }
  
  // inverter class
  function createInverter(node1, node2) {
    return {
      'class': 'inverter',
      'in': node1,
      'out': node2,
      'state': false,
      'function': function() {
        if (this.in.state == true) {
          this.state = true;
          this.out.state = false;
        }
        if (this.in.state == false) {
          this.state = false;
          this.out.state = true;
        }
      }
    };
  }
  
  // render element
  function renderElement(e) {
    switch (e.class) {
      case 'node':
        context.fillStyle = NODE_COLOR;
        context.lineWidth = NODE_LINE_WIDTH;
        context.strokeStyle = NODE_COLOR;
        context.beginPath();
        if (e.active) context.rect(e.x-NODE_RADIUS, e.y-NODE_RADIUS, 2*NODE_RADIUS, 2*NODE_RADIUS);
        else context.arc(e.x, e.y, NODE_RADIUS, 0, 2 * Math.PI);
        context.stroke();
        e.state ? context.fill() : 0;
        break;
      case 'wire':
        context.lineWidth = WIRE_LINE_WIDTH;
        context.strokeStyle = e.state ? WIRE_COLOR_ON : WIRE_COLOR_OFF;
        context.beginPath();
        context.moveTo(e.in.x, e.in.y);
        context.lineTo(e.out.x, e.out.y);
        context.stroke();
        context.closePath();
        break
      case 'inverter':
        let invX = e.in.x + (e.out.x - e.in.x)/2;
        let invY = e.in.y + (e.out.y - e.in.y)/2;
        context.lineWidth = WIRE_LINE_WIDTH;
        context.strokeStyle = e.state ? WIRE_COLOR_ON : WIRE_COLOR_OFF;
        context.beginPath();
        context.moveTo(e.in.x, e.in.y);
        context.lineTo(invX, invY);
        context.stroke();
        context.closePath();
        context.fillStyle = NODE_COLOR;
        context.strokeStyle = NODE_COLOR;
        context.beginPath();
        context.arc(invX, invY, NODE_RADIUS*1.5, 0, 2 * Math.PI);
        e.state ? context.stroke() : context.fill();
        context.closePath();
        context.strokeStyle = e.state ? WIRE_COLOR_OFF : WIRE_COLOR_ON;
        context.beginPath();
        context.moveTo(invX, invY);
        context.lineTo(e.out.x, e.out.y);
        context.stroke();
        context.closePath();
        break;
    }
  }

  // render frame
  function renderFrame() {
    // loop over circuit elements
    for (let i = 0; i < circuit.length; i++) {
      // pick up element
      let element = circuit[i];

      // update state
      element.function();
      
      // render element
      renderElement(element); 
    }
  }
  
  
  
  /*circle
  
  var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
ctx.beginPath();
ctx.arc(100, 75, 50, 0, 2 * Math.PI);
ctx.stroke();*/

/*rect
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
ctx.beginPath();
ctx.rect(20, 20, 150, 100);
ctx.stroke();

*/

  // 
  /*function fillTriangle(x1, y1, x2, y2, x3, y3, color) {
    context.fillStyle = color;
    context.strokeStyle = color;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(x3, y3);
    context.lineTo(x1, y1);
    context.closePath();
    context.stroke();
    context.fill();
  }*/
  
  // render triangle
  /*function drawTriangle(x1, y1, x2, y2, x3, y3, color) {
    context.strokeStyle = color;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(x3, y3);
    context.lineTo(x1, y1);
    context.closePath();
    context.stroke();
  }*/
  
  // click handle
  canvas.addEventListener('click', function(e) {  // use event argument

    var rect = canvas.getBoundingClientRect();  // get element's abs. position
    var x = e.clientX - rect.left;              // get mouse x and adjust for el.
    var y = e.clientY - rect.top;               // get mouse y and adjust for el.
    
    let element = {'class': 'none'};
    for (let i = 0; i < circuit.length; i++) {
      let currentElement = circuit[i]; 
      if (currentElement.class == 'node' && currentElement.active == true) {
        if (Math.abs(currentElement.x - x) <= NODE_RADIUS &&
            Math.abs(currentElement.y - y) <= NODE_RADIUS)
          currentElement.onClick();
      }
    }
  
  });

  // move camera
  document.onkeydown = function(event) {
    switch (event.keyCode) {
      case 38: camera[1] += 0.1; break;         /* arrow up     */
      case 40: camera[1] -= 0.1; break;         /* arrow down   */
      case 37: camera[0] += 0.1; break;         /* arrow left   */
      case 39: camera[0] -= 0.1; break;         /* arrow right  */
      case 65: Yaw -= 0.1; break;               /* 'a'          */
      case 68: Yaw += 0.1; break;               /* 'd'          */
      case 87:
        let forward = vectorMul(lookDirection, 0.1);  /* 'w'    */
        camera = vectorAdd(camera, forward);
        break;
      case 83: { 
        let forward = vectorMul(lookDirection, 0.1);  /* 's'    */
        camera = vectorSub(camera, forward);
        break;
      }
    }
  }

  // game loop
  function gameLoop() {
    // calculate FPS
    cycleCount++;
    if (cycleCount >= 60) cycleCount = 0;
    var startTime = Date.now();
    var cycleTime = startTime - oldCycleTime;
    oldCycleTime = startTime;
    if (cycleCount % 60 == 0) fps_rate = Math.floor(1000 / cycleTime);
    
    // resize canvas
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    
    // update screen
    context.fillStyle = 'Black';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // render frame
    renderFrame();
  
    // infinite loop
    requestAnimationFrame(gameLoop);
    
    // render FPS to screen
    context.fillStyle = 'white';
    context.font = '10px Monospace';
    context.fillText('FPS: ' + fps_rate, 0, 20);
    
  } window.onload = function() { gameLoop(); }
  
</script>